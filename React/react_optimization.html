<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 性能优化 | 前端面试深入指南</title>
    <meta name="description" content="一个记录前端面经的个人博客">
    <meta name="generator" content="VitePress v1.3.0">
    <link rel="preload stylesheet" href="/fe-blog/assets/style.DNGC3m6O.css" as="style">
    
    <script type="module" src="/fe-blog/assets/app.e_z1PHhQ.js"></script>
    <link rel="preload" href="/fe-blog/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/fe-blog/assets/chunks/framework.BENtzm8J.js">
    <link rel="modulepreload" href="/fe-blog/assets/chunks/theme.kT1KBtTN.js">
    <link rel="modulepreload" href="/fe-blog/assets/React_react_optimization.md.CoxuajHt.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar has-sidebar top" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-ab179fa1><a class="title" href="/fe-blog/" data-v-ab179fa1><!--[--><!--]--><!----><span data-v-ab179fa1>前端面试深入指南</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/fe-blog/JavaScript.html" tabindex="0" data-v-dc692963 data-v-9c663999><!--[--><span data-v-9c663999>JavaScript</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/fe-blog/React.html" tabindex="0" data-v-dc692963 data-v-9c663999><!--[--><span data-v-9c663999>React</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/fe-blog/Algorithms.html" tabindex="0" data-v-dc692963 data-v-9c663999><!--[--><span data-v-9c663999>数据结构和算法</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zuckstar/fe-blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zuckstar/fe-blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b7550ba0><div class="item" role="button" tabindex="0" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><h2 class="text" data-v-b7550ba0>React 技术栈</h2><!----></div><div class="items" data-v-b7550ba0><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/fe-blog/React/react_router.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>React Router</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/fe-blog/React/set_state.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>setState</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/fe-blog/React/fiber.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>fiber 架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/fe-blog/React/event.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>React 合成事件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/fe-blog/React/react_optimization.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>React 性能优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/fe-blog/React/react_redux.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>Redux</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _fe-blog_React_react_optimization" data-v-39a288b8><div><h1 id="react-性能优化" tabindex="-1">React 性能优化 <a class="header-anchor" href="#react-性能优化" aria-label="Permalink to &quot;React 性能优化&quot;">​</a></h1><h2 id="在-react-中可以做哪些性能优化" tabindex="-1">在 React 中可以做哪些性能优化？ <a class="header-anchor" href="#在-react-中可以做哪些性能优化" aria-label="Permalink to &quot;在 React 中可以做哪些性能优化？&quot;">​</a></h2><ul><li><p>列表项使用 key 属性</p></li><li><p>类组件: 使用 shouldComponentUpdate 避免不必要的渲染</p></li><li><p>函数组件：</p><ul><li>React.memo 避免不必要的渲染</li><li>useMemo、useCallback <ul><li>useMemo 返回缓存的值</li><li>useCallback 返回缓存的函数</li></ul></li></ul></li><li><p>避免不必要的渲染</p><ul><li>合理地使用条件渲染,避免渲染无用的 DOM 元素。</li><li>使用 React.Fragment 或空标签&lt;&gt;...&lt;/&gt; 来替代无意义的 DOM 包裹，减少嵌套层级</li></ul></li><li><p>拆分组件</p><ul><li>将大型组件拆分为更小的可重用组件,可以提高组件的复用性和渲染效率。</li></ul></li></ul><h2 id="usecallback-和-usememo" tabindex="-1">useCallback 和 useMemo <a class="header-anchor" href="#usecallback-和-usememo" aria-label="Permalink to &quot;useCallback 和 useMemo&quot;">​</a></h2><h3 id="根本区别" tabindex="-1">根本区别： <a class="header-anchor" href="#根本区别" aria-label="Permalink to &quot;根本区别：&quot;">​</a></h3><ol><li>useMemo 用于缓存计算结果值，而 useCallback 用于缓存函数引用。 更具体来说对第一个函数参数的处理方式不同，useMemo 是执行函数后缓存执行的结果，useCallback 直接对传入的函数引用进行缓存。他们都会在依赖项发生变化的时候重新执行函数。</li></ol><h3 id="意义" tabindex="-1">意义： <a class="header-anchor" href="#意义" aria-label="Permalink to &quot;意义：&quot;">​</a></h3><ol><li><p>使用 useMemo 可以避免重复进行昂贵的计算操作,提高性能。</p></li><li><p>使用 useCallback 可以避免不必要的函数重新创建,提高性能,并且可以在子组件中使用记忆函数,减少不必要的重渲染。</p></li></ol><h3 id="使用场景" tabindex="-1">使用场景： <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景：&quot;">​</a></h3><ol><li><p>对于一些昂贵的计算,比如大量数据的排序、过滤等操作,可以使用 useMemo 进行缓存,避免重复计算。</p></li><li><p>当你在组件树中层层传递回调函数时，可以使用 useCallback 来避免不必要的函数重新创建，提高性能。</p></li><li><p>如果一个组件的渲染依赖于一个复杂的对象,使用 useMemo 可以避免每次渲染都重新创建这个对象。</p></li></ol><h3 id="防止不必要的-effect" tabindex="-1">防止不必要的 effect <a class="header-anchor" href="#防止不必要的-effect" aria-label="Permalink to &quot;防止不必要的 effect&quot;">​</a></h3><p>如果一个值被 useEffect 依赖，那它可能需要被缓存，这样可以避免重复执行 effect。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在 re-renders 之间缓存 a 的引用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ test: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }), []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 只有当 a 的值变化时，这里才会被触发</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [a]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // the rest of the code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="防止不必要的-re-render" tabindex="-1">防止不必要的 re-render <a class="header-anchor" href="#防止不必要的-re-render" aria-label="Permalink to &quot;防止不必要的 re-render&quot;">​</a></h3><p>三种情况会 re-render:</p><ol><li><p>当组件本身的 props 或者 state 改变时</p></li><li><p>context value 改变时，使用该值的组件会 re-render</p></li><li><p>当父组件重新渲染时，它的所有的子组件会 re-render，形成一条 re-render 链</p></li></ol><p>第三个 re-render 时机经常被开发者忽视，导致代码中存在大量的无效缓存。</p><p>例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Do something on click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 无论 onClick 是否被缓存，Page 都会 re-render</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Page</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{onClick} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>当使用 setState 改变 state 时，App 会 re-render，作为子组件的 Page 也会跟着 re-render。这里 useCallback 是完全无效的，它并不能阻止 Page 的 re-render。</p><h3 id="如何防止子组件-re-render" tabindex="-1">如何防止子组件 re-render <a class="header-anchor" href="#如何防止子组件-re-render" aria-label="Permalink to &quot;如何防止子组件 re-render&quot;">​</a></h3><p>必须同时缓存 onClick 和组件本身，才能实现 Page 不触发 re-render。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PageMemoized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Page);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Do something on click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Page 和 onClick 同时 memorize</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PageMemoized</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{onClick} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>由于使用了 React.memo，PageMemoized 会浅比较 props 的变化后再决定是否 re-render。onClick 被缓存后不会再变化，所以 PageMemoized 不再 re-render。</p><p>现在可以得出结论了，必须同时满足以下两个条件，子组件才不会 re-render：</p><ol><li><p>子组件自身被缓存。</p></li><li><p>子组件所有的 prop 都被缓存。</p></li></ol><p>那应该什么时候缓存组件，怎么判断一个组件的渲染是昂贵的？</p><p>很遗憾，似乎没有一个简单&amp;无侵入&amp;自动的衡量方式。通常来说有两个方式：</p><ol><li>人肉判断，开发或者测试人员在研发过程中感知到渲染性能问题，并进行判断。</li><li>通过工具，目前有一些工具协助开发者在查看组件性能:</li></ol><ul><li>如 React Dev Tools Profiler</li><li>如这个 hooks：useRenderTimes</li></ul><p>另外，React 在 16.5 版本后提供了 Profiler API：它可以识别出应用中渲染较慢的部分，或是可以使用类似 memoization 优化的部分。所以可以通过 puppeteer 或 cypress 在自动化集成中测试组件性能，这很适合核心组件的性能测试。</p><h3 id="如何判断子组件需要缓存" tabindex="-1">如何判断子组件需要缓存 <a class="header-anchor" href="#如何判断子组件需要缓存" aria-label="Permalink to &quot;如何判断子组件需要缓存&quot;">​</a></h3><p>我们已经了解，为了防止子组件 re-render，需要以下成本：</p><ol><li><p>开发者工作量的增加： 一旦使用缓存，就必须保证组件本身以及所有 props 都缓存，后续添加的所有 props 都要缓存。</p></li><li><p>代码复杂度和可读性的变化：代码中出现大量缓存函数，这会增加代码复杂度，并降低易读性。</p></li></ol><p>除此之外还有另外一个成本：性能成本。 组件的缓存是在初始化时进行，虽然每个组件缓存的性能耗费很低，通常不足 1ms，但大型程序里成百上千的组件如果同时初始化缓存，成本可能会变得很可观。</p><p>所以局部使用 memo，比全局使用显的更优雅、性能更好，坏处是需要开发者主动去判断是否需要缓存该子组件。</p><h3 id="防止不必要的重复计算" tabindex="-1">防止不必要的重复计算 <a class="header-anchor" href="#防止不必要的重复计算" aria-label="Permalink to &quot;防止不必要的重复计算&quot;">​</a></h3><p>组件渲染才是性能的瓶颈，应该把 useMemo 用在程序里渲染昂贵的组件上，而不是数值计算上。当然，除非这个计算真的很昂贵，比如阶乘计算。</p><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>讲到这里我们可以总结出 useMemo/useCallback 使用准则了：</p><ol><li><p>大部分的 useMemo 和 useCallback 都应该移除，他们可能没有带来任何性能上的优化，反而增加了程序首次渲染的负担，并增加程序的复杂性。</p></li><li><p>使用 useMemo 和 useCallback 优化子组件 re-render 时，必须同时满足以下条件才有效。</p></li></ol><ul><li>子组件已通过 React.memo 或 useMemo 被缓存</li><li>子组件所有的 prop 都被缓存</li></ul><ol start="3"><li>不推荐默认给所有组件都使用缓存，大量组件初始化时被缓存，可能导致过多的内存消耗，并影响程序初始化渲染的速度。</li></ol><h2 id="使用-react-memo" tabindex="-1">使用 React.memo <a class="header-anchor" href="#使用-react-memo" aria-label="Permalink to &quot;使用 React.memo&quot;">​</a></h2><p>React.memo 是 React 提供的一个高阶组件(Higher-Order Component,HOC),它的主要作用如下:</p><h3 id="_1-性能优化" tabindex="-1">1. 性能优化 <a class="header-anchor" href="#_1-性能优化" aria-label="Permalink to &quot;1. 性能优化&quot;">​</a></h3><ul><li>React.memo 通过对组件的 props 进行浅层比较来决定是否需要重新渲染组件。如果 props 没有发生变化，则不会重新渲染该组件，从而提高性能。</li></ul><h3 id="_2-避免不必要的重新渲染" tabindex="-1">2. 避免不必要的重新渲染 <a class="header-anchor" href="#_2-避免不必要的重新渲染" aria-label="Permalink to &quot;2. 避免不必要的重新渲染&quot;">​</a></h3><ul><li>对于一些纯粹的、输入输出关系简单的组件,使用 React.memo 可以避免不必要的重新渲染,减少不必要的 DOM 操作,提高应用程序的整体性能。</li></ul><h2 id="为什么过度使用-usecallback-可能会造成性能问题" tabindex="-1">为什么过度使用 useCallback 可能会造成性能问题？ <a class="header-anchor" href="#为什么过度使用-usecallback-可能会造成性能问题" aria-label="Permalink to &quot;为什么过度使用 useCallback 可能会造成性能问题？&quot;">​</a></h2><h3 id="_1-过度缓存函数引用" tabindex="-1">1. 过度缓存函数引用 <a class="header-anchor" href="#_1-过度缓存函数引用" aria-label="Permalink to &quot;1. 过度缓存函数引用&quot;">​</a></h3><ul><li>useCallback 的作用是缓存函数引用,以避免不必要的函数重新创建。但如果滥用 useCallback,就会导致大量函数引用被缓存,占用了不必要的内存空间。</li></ul><h3 id="_2-增加渲染开销" tabindex="-1">2. 增加渲染开销 <a class="header-anchor" href="#_2-增加渲染开销" aria-label="Permalink to &quot;2. 增加渲染开销&quot;">​</a></h3><ul><li>每次组件渲染时,React 都需要检查 useCallback 的依赖项是否发生变化,以决定是否需要重新创建函数。如果依赖项很多,这个检查过程就会增加渲染的开销。</li></ul><h3 id="_3-增加代码复杂度" tabindex="-1">3. 增加代码复杂度 <a class="header-anchor" href="#_3-增加代码复杂度" aria-label="Permalink to &quot;3. 增加代码复杂度&quot;">​</a></h3><ul><li>过度使用 useCallback 会让代码变得复杂,降低可读性和可维护性。开发者需要时刻注意函数依赖项的变化,以确保正确使用 useCallback。</li></ul><h3 id="_4-潜在的内存泄漏" tabindex="-1">4. 潜在的内存泄漏 <a class="header-anchor" href="#_4-潜在的内存泄漏" aria-label="Permalink to &quot;4. 潜在的内存泄漏&quot;">​</a></h3><ul><li>如果 useCallback 缓存的函数引用没有被正确释放,就可能造成内存泄漏。这需要开发者格外小心,确保组件卸载时正确清理缓存的函数引用。</li></ul><h2 id="在-react-中组件为何要设置-key-属性" tabindex="-1">在 React 中组件为何要设置 key 属性？ <a class="header-anchor" href="#在-react-中组件为何要设置-key-属性" aria-label="Permalink to &quot;在 React 中组件为何要设置 key 属性？&quot;">​</a></h2><h3 id="_1-助-react-识别组件的唯一性-提高更新效率" tabindex="-1">1. 助 React 识别组件的唯一性，提高更新效率 <a class="header-anchor" href="#_1-助-react-识别组件的唯一性-提高更新效率" aria-label="Permalink to &quot;1. 助 React 识别组件的唯一性，提高更新效率&quot;">​</a></h3><ul><li>当 React 渲染一个列表时，需要知道哪些项目发生了变化,哪些项目被添加或移除了。key 属性可以帮助 React 唯一标识每个列表项，从而更高效地进行比较和更新。通过 key 属性的唯一标识，React 可以更快地找到需要更新的元素，减少不必要的比较和调和操作，从而提高整体的更新效率。</li></ul><h3 id="_2-优化-dom-操作" tabindex="-1">2. 优化 DOM 操作 <a class="header-anchor" href="#_2-优化-dom-操作" aria-label="Permalink to &quot;2. 优化 DOM 操作&quot;">​</a></h3><ul><li>有了 key 属性,React 就可以根据 key 值识别哪些元素发生了变化,从而只更新发生变化的部分,减少不必要的 DOM 操作,提高性能。</li></ul><h3 id="_3-避免组件状态丢失" tabindex="-1">3. 避免组件状态丢失 <a class="header-anchor" href="#_3-避免组件状态丢失" aria-label="Permalink to &quot;3. 避免组件状态丢失&quot;">​</a></h3><ul><li>当列表发生变化时,如果没有设置 key 属性,React 可能会错误地认为组件没有发生变化,导致组件状态丢失。设置 key 可以确保 React 能够正确地识别组件,保持组件状态不变。</li></ul><h3 id="_4-index-作为-key-是否合适" tabindex="-1">4. index 作为 key 是否合适？ <a class="header-anchor" href="#_4-index-作为-key-是否合适" aria-label="Permalink to &quot;4. index 作为 key 是否合适？&quot;">​</a></h3><ul><li>涉及新增删除的场景不合适：index 设置为 key 不合适，头部新增节点后会更新多个节点</li><li>不涉及位置变动，只涉及修改数据的场景合适</li></ul><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><p><a href="https://fe.ecool.fun/topic-answer/f10c4b00-cceb-4323-97dc-55b315b05024?orderBy=updateTime&amp;order=desc" target="_blank" rel="noreferrer">我们应该在什么场景下使用 useMemo 和 useCallback </a></p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/fe-blog/React/event.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>React 合成事件</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/fe-blog/React/react_redux.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>Redux</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"algorithms_index.md\":\"BUkaUpZF\",\"css_bfc.md\":\"H9x9Z7Ot\",\"css_flex.md\":\"Bu4wOTcI\",\"css_index.md\":\"X9fWbMWS\",\"css_mobile.md\":\"CpaFxWOS\",\"index.md\":\"CqtZQ8sI\",\"introduce.md\":\"JaAnzbvK\",\"javascript_basic_types.md\":\"B61Gku3b\",\"javascript_call_apply_bind.md\":\"DuFsHNaN\",\"javascript_closure.md\":\"DMEzF3E9\",\"javascript_code.md\":\"VQMnA6FP\",\"javascript_copy.md\":\"CT8lvXcJ\",\"javascript_curry.md\":\"CgYqICmx\",\"javascript_event.md\":\"DUEmvhOv\",\"javascript_index.md\":\"BBQ-i97_\",\"javascript_new.md\":\"CJ-juODd\",\"javascript_prototype.md\":\"CprKIMY7\",\"network_cdn.md\":\"CpHeBfK0\",\"network_dns.md\":\"Dlzkgx_7\",\"network_index.md\":\"DmLz8RX1\",\"react_event.md\":\"D6BpUujt\",\"react_fiber.md\":\"DUAgEadu\",\"react_index.md\":\"CbudPeKf\",\"react_react_optimization.md\":\"CoxuajHt\",\"react_react_redux.md\":\"B-EISXuu\",\"react_react_router.md\":\"CQtM4VE9\",\"react_set_state.md\":\"BFH13s0-\",\"react_ssr.md\":\"51YNXyD5\",\"webpack_index.md\":\"CN7m4a5-\",\"webpack_play.md\":\"C-Au42t7\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试深入指南\",\"description\":\"一个记录前端面经的个人博客\",\"base\":\"/fe-blog/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"search\":{\"provider\":\"local\"},\"nav\":[{\"text\":\"JavaScript\",\"link\":\"/JavaScript\"},{\"text\":\"React\",\"link\":\"/React\"},{\"text\":\"数据结构和算法\",\"link\":\"/Algorithms\"}],\"sidebar\":{\"/JavaScript\":[{\"text\":\"JavaScript 基础\",\"items\":[{\"text\":\"数据类型\",\"link\":\"/JavaScript/basic_types.md\"},{\"text\":\"new 运算符\",\"link\":\"/JavaScript/new\"},{\"text\":\"闭包\",\"link\":\"/JavaScript/closure\"},{\"text\":\"浅拷贝和深拷贝\",\"link\":\"/JavaScript/copy\"},{\"text\":\"原型、原型链和继承\",\"link\":\"/JavaScript/prototype\"},{\"text\":\"call、apply、bind 方法\",\"link\":\"/JavaScript/call_apply_bind\"},{\"text\":\"事件\",\"link\":\"/JavaScript/event.md\"},{\"text\":\"代码题\",\"link\":\"/JavaScript/code.md\"}]}],\"/CSS\":[{\"text\":\"CSS 基础\",\"items\":[{\"text\":\"flex 布局\",\"link\":\"/CSS/flex\"},{\"text\":\"什么是 BFC?\",\"link\":\"/CSS/bfc\"},{\"text\":\"移动端适配\",\"link\":\"/CSS/mobile\"}]}],\"/React\":[{\"text\":\"React 技术栈\",\"items\":[{\"text\":\"React Router\",\"link\":\"/React/react_router\"},{\"text\":\"setState\",\"link\":\"/React/set_state\"},{\"text\":\"fiber 架构\",\"link\":\"/React/fiber\"},{\"text\":\"React 合成事件\",\"link\":\"/React/event.md\"},{\"text\":\"React 性能优化\",\"link\":\"/React/react_optimization.md\"},{\"text\":\"Redux\",\"link\":\"/React/react_redux.md\"}]}],\"/Network\":[{\"text\":\"计算机网络\",\"items\":[{\"text\":\"CDN\",\"link\":\"/Network/cdn\"}]}],\"/Webpack\":[{\"text\":\"Webpack\",\"items\":[{\"text\":\"Webpack 原理\",\"link\":\"/Webpack\"},{\"text\":\"玩转 Webpack\",\"link\":\"/Webpack/play\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/zuckstar/fe-blog\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>