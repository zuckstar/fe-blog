import{_ as s,c as a,o as i,a4 as e}from"./chunks/framework.BENtzm8J.js";const u=JSON.parse('{"title":"React 性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"React/react_optimization.md","filePath":"React/react_optimization.md"}'),l={name:"React/react_optimization.md"},n=e(`<h1 id="react-性能优化" tabindex="-1">React 性能优化 <a class="header-anchor" href="#react-性能优化" aria-label="Permalink to &quot;React 性能优化&quot;">​</a></h1><h2 id="在-react-中可以做哪些性能优化" tabindex="-1">在 React 中可以做哪些性能优化？ <a class="header-anchor" href="#在-react-中可以做哪些性能优化" aria-label="Permalink to &quot;在 React 中可以做哪些性能优化？&quot;">​</a></h2><ul><li><p>列表项使用 key 属性</p></li><li><p>类组件: 使用 shouldComponentUpdate 避免不必要的渲染</p></li><li><p>函数组件：</p><ul><li>React.memo 避免不必要的渲染</li><li>useMemo、useCallback <ul><li>useMemo 返回缓存的值</li><li>useCallback 返回缓存的函数</li></ul></li></ul></li><li><p>避免不必要的渲染</p><ul><li>合理地使用条件渲染,避免渲染无用的 DOM 元素。</li><li>使用 React.Fragment 或空标签&lt;&gt;...&lt;/&gt; 来替代无意义的 DOM 包裹，减少嵌套层级</li></ul></li><li><p>拆分组件</p><ul><li>将大型组件拆分为更小的可重用组件,可以提高组件的复用性和渲染效率。</li></ul></li></ul><h2 id="usecallback-和-usememo" tabindex="-1">useCallback 和 useMemo <a class="header-anchor" href="#usecallback-和-usememo" aria-label="Permalink to &quot;useCallback 和 useMemo&quot;">​</a></h2><h3 id="根本区别" tabindex="-1">根本区别： <a class="header-anchor" href="#根本区别" aria-label="Permalink to &quot;根本区别：&quot;">​</a></h3><ol><li>useMemo 用于缓存计算结果值，而 useCallback 用于缓存函数引用。 更具体来说对第一个函数参数的处理方式不同，useMemo 是执行函数后缓存执行的结果，useCallback 直接对传入的函数引用进行缓存。他们都会在依赖项发生变化的时候重新执行函数。</li></ol><h3 id="意义" tabindex="-1">意义： <a class="header-anchor" href="#意义" aria-label="Permalink to &quot;意义：&quot;">​</a></h3><ol><li><p>使用 useMemo 可以避免重复进行昂贵的计算操作,提高性能。</p></li><li><p>使用 useCallback 可以避免不必要的函数重新创建,提高性能,并且可以在子组件中使用记忆函数,减少不必要的重渲染。</p></li></ol><h3 id="使用场景" tabindex="-1">使用场景： <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景：&quot;">​</a></h3><ol><li><p>对于一些昂贵的计算,比如大量数据的排序、过滤等操作,可以使用 useMemo 进行缓存,避免重复计算。</p></li><li><p>当你在组件树中层层传递回调函数时，可以使用 useCallback 来避免不必要的函数重新创建，提高性能。</p></li><li><p>如果一个组件的渲染依赖于一个复杂的对象,使用 useMemo 可以避免每次渲染都重新创建这个对象。</p></li></ol><h3 id="防止不必要的-effect" tabindex="-1">防止不必要的 effect <a class="header-anchor" href="#防止不必要的-effect" aria-label="Permalink to &quot;防止不必要的 effect&quot;">​</a></h3><p>如果一个值被 useEffect 依赖，那它可能需要被缓存，这样可以避免重复执行 effect。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在 re-renders 之间缓存 a 的引用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ test: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }), []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 只有当 a 的值变化时，这里才会被触发</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [a]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // the rest of the code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="防止不必要的-re-render" tabindex="-1">防止不必要的 re-render <a class="header-anchor" href="#防止不必要的-re-render" aria-label="Permalink to &quot;防止不必要的 re-render&quot;">​</a></h3><p>三种情况会 re-render:</p><ol><li><p>当组件本身的 props 或者 state 改变时</p></li><li><p>context value 改变时，使用该值的组件会 re-render</p></li><li><p>当父组件重新渲染时，它的所有的子组件会 re-render，形成一条 re-render 链</p></li></ol><p>第三个 re-render 时机经常被开发者忽视，导致代码中存在大量的无效缓存。</p><p>例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Do something on click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 无论 onClick 是否被缓存，Page 都会 re-render</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Page</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{onClick} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>当使用 setState 改变 state 时，App 会 re-render，作为子组件的 Page 也会跟着 re-render。这里 useCallback 是完全无效的，它并不能阻止 Page 的 re-render。</p><h3 id="如何防止子组件-re-render" tabindex="-1">如何防止子组件 re-render <a class="header-anchor" href="#如何防止子组件-re-render" aria-label="Permalink to &quot;如何防止子组件 re-render&quot;">​</a></h3><p>必须同时缓存 onClick 和组件本身，才能实现 Page 不触发 re-render。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PageMemoized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Page);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Do something on click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Page 和 onClick 同时 memorize</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PageMemoized</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{onClick} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>由于使用了 React.memo，PageMemoized 会浅比较 props 的变化后再决定是否 re-render。onClick 被缓存后不会再变化，所以 PageMemoized 不再 re-render。</p><p>现在可以得出结论了，必须同时满足以下两个条件，子组件才不会 re-render：</p><ol><li><p>子组件自身被缓存。</p></li><li><p>子组件所有的 prop 都被缓存。</p></li></ol><p>那应该什么时候缓存组件，怎么判断一个组件的渲染是昂贵的？</p><p>很遗憾，似乎没有一个简单&amp;无侵入&amp;自动的衡量方式。通常来说有两个方式：</p><ol><li>人肉判断，开发或者测试人员在研发过程中感知到渲染性能问题，并进行判断。</li><li>通过工具，目前有一些工具协助开发者在查看组件性能:</li></ol><ul><li>如 React Dev Tools Profiler</li><li>如这个 hooks：useRenderTimes</li></ul><p>另外，React 在 16.5 版本后提供了 Profiler API：它可以识别出应用中渲染较慢的部分，或是可以使用类似 memoization 优化的部分。所以可以通过 puppeteer 或 cypress 在自动化集成中测试组件性能，这很适合核心组件的性能测试。</p><h3 id="如何判断子组件需要缓存" tabindex="-1">如何判断子组件需要缓存 <a class="header-anchor" href="#如何判断子组件需要缓存" aria-label="Permalink to &quot;如何判断子组件需要缓存&quot;">​</a></h3><p>我们已经了解，为了防止子组件 re-render，需要以下成本：</p><ol><li><p>开发者工作量的增加： 一旦使用缓存，就必须保证组件本身以及所有 props 都缓存，后续添加的所有 props 都要缓存。</p></li><li><p>代码复杂度和可读性的变化：代码中出现大量缓存函数，这会增加代码复杂度，并降低易读性。</p></li></ol><p>除此之外还有另外一个成本：性能成本。 组件的缓存是在初始化时进行，虽然每个组件缓存的性能耗费很低，通常不足 1ms，但大型程序里成百上千的组件如果同时初始化缓存，成本可能会变得很可观。</p><p>所以局部使用 memo，比全局使用显的更优雅、性能更好，坏处是需要开发者主动去判断是否需要缓存该子组件。</p><h3 id="防止不必要的重复计算" tabindex="-1">防止不必要的重复计算 <a class="header-anchor" href="#防止不必要的重复计算" aria-label="Permalink to &quot;防止不必要的重复计算&quot;">​</a></h3><p>组件渲染才是性能的瓶颈，应该把 useMemo 用在程序里渲染昂贵的组件上，而不是数值计算上。当然，除非这个计算真的很昂贵，比如阶乘计算。</p><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>讲到这里我们可以总结出 useMemo/useCallback 使用准则了：</p><ol><li><p>大部分的 useMemo 和 useCallback 都应该移除，他们可能没有带来任何性能上的优化，反而增加了程序首次渲染的负担，并增加程序的复杂性。</p></li><li><p>使用 useMemo 和 useCallback 优化子组件 re-render 时，必须同时满足以下条件才有效。</p></li></ol><ul><li>子组件已通过 React.memo 或 useMemo 被缓存</li><li>子组件所有的 prop 都被缓存</li></ul><ol start="3"><li>不推荐默认给所有组件都使用缓存，大量组件初始化时被缓存，可能导致过多的内存消耗，并影响程序初始化渲染的速度。</li></ol><h2 id="使用-react-memo" tabindex="-1">使用 React.memo <a class="header-anchor" href="#使用-react-memo" aria-label="Permalink to &quot;使用 React.memo&quot;">​</a></h2><p>React.memo 是 React 提供的一个高阶组件(Higher-Order Component,HOC),它的主要作用如下:</p><h3 id="_1-性能优化" tabindex="-1">1. 性能优化 <a class="header-anchor" href="#_1-性能优化" aria-label="Permalink to &quot;1. 性能优化&quot;">​</a></h3><ul><li>React.memo 通过对组件的 props 进行浅层比较来决定是否需要重新渲染组件。如果 props 没有发生变化，则不会重新渲染该组件，从而提高性能。</li></ul><h3 id="_2-避免不必要的重新渲染" tabindex="-1">2. 避免不必要的重新渲染 <a class="header-anchor" href="#_2-避免不必要的重新渲染" aria-label="Permalink to &quot;2. 避免不必要的重新渲染&quot;">​</a></h3><ul><li>对于一些纯粹的、输入输出关系简单的组件,使用 React.memo 可以避免不必要的重新渲染,减少不必要的 DOM 操作,提高应用程序的整体性能。</li></ul><h2 id="为什么过度使用-usecallback-可能会造成性能问题" tabindex="-1">为什么过度使用 useCallback 可能会造成性能问题？ <a class="header-anchor" href="#为什么过度使用-usecallback-可能会造成性能问题" aria-label="Permalink to &quot;为什么过度使用 useCallback 可能会造成性能问题？&quot;">​</a></h2><h3 id="_1-过度缓存函数引用" tabindex="-1">1. 过度缓存函数引用 <a class="header-anchor" href="#_1-过度缓存函数引用" aria-label="Permalink to &quot;1. 过度缓存函数引用&quot;">​</a></h3><ul><li>useCallback 的作用是缓存函数引用,以避免不必要的函数重新创建。但如果滥用 useCallback,就会导致大量函数引用被缓存,占用了不必要的内存空间。</li></ul><h3 id="_2-增加渲染开销" tabindex="-1">2. 增加渲染开销 <a class="header-anchor" href="#_2-增加渲染开销" aria-label="Permalink to &quot;2. 增加渲染开销&quot;">​</a></h3><ul><li>每次组件渲染时,React 都需要检查 useCallback 的依赖项是否发生变化,以决定是否需要重新创建函数。如果依赖项很多,这个检查过程就会增加渲染的开销。</li></ul><h3 id="_3-增加代码复杂度" tabindex="-1">3. 增加代码复杂度 <a class="header-anchor" href="#_3-增加代码复杂度" aria-label="Permalink to &quot;3. 增加代码复杂度&quot;">​</a></h3><ul><li>过度使用 useCallback 会让代码变得复杂,降低可读性和可维护性。开发者需要时刻注意函数依赖项的变化,以确保正确使用 useCallback。</li></ul><h3 id="_4-潜在的内存泄漏" tabindex="-1">4. 潜在的内存泄漏 <a class="header-anchor" href="#_4-潜在的内存泄漏" aria-label="Permalink to &quot;4. 潜在的内存泄漏&quot;">​</a></h3><ul><li>如果 useCallback 缓存的函数引用没有被正确释放,就可能造成内存泄漏。这需要开发者格外小心,确保组件卸载时正确清理缓存的函数引用。</li></ul><h2 id="在-react-中组件为何要设置-key-属性" tabindex="-1">在 React 中组件为何要设置 key 属性？ <a class="header-anchor" href="#在-react-中组件为何要设置-key-属性" aria-label="Permalink to &quot;在 React 中组件为何要设置 key 属性？&quot;">​</a></h2><h3 id="_1-助-react-识别组件的唯一性-提高更新效率" tabindex="-1">1. 助 React 识别组件的唯一性，提高更新效率 <a class="header-anchor" href="#_1-助-react-识别组件的唯一性-提高更新效率" aria-label="Permalink to &quot;1. 助 React 识别组件的唯一性，提高更新效率&quot;">​</a></h3><ul><li>当 React 渲染一个列表时，需要知道哪些项目发生了变化,哪些项目被添加或移除了。key 属性可以帮助 React 唯一标识每个列表项，从而更高效地进行比较和更新。通过 key 属性的唯一标识，React 可以更快地找到需要更新的元素，减少不必要的比较和调和操作，从而提高整体的更新效率。</li></ul><h3 id="_2-优化-dom-操作" tabindex="-1">2. 优化 DOM 操作 <a class="header-anchor" href="#_2-优化-dom-操作" aria-label="Permalink to &quot;2. 优化 DOM 操作&quot;">​</a></h3><ul><li>有了 key 属性,React 就可以根据 key 值识别哪些元素发生了变化,从而只更新发生变化的部分,减少不必要的 DOM 操作,提高性能。</li></ul><h3 id="_3-避免组件状态丢失" tabindex="-1">3. 避免组件状态丢失 <a class="header-anchor" href="#_3-避免组件状态丢失" aria-label="Permalink to &quot;3. 避免组件状态丢失&quot;">​</a></h3><ul><li>当列表发生变化时,如果没有设置 key 属性,React 可能会错误地认为组件没有发生变化,导致组件状态丢失。设置 key 可以确保 React 能够正确地识别组件,保持组件状态不变。</li></ul><h3 id="_4-index-作为-key-是否合适" tabindex="-1">4. index 作为 key 是否合适？ <a class="header-anchor" href="#_4-index-作为-key-是否合适" aria-label="Permalink to &quot;4. index 作为 key 是否合适？&quot;">​</a></h3><ul><li>涉及新增删除的场景不合适：index 设置为 key 不合适，头部新增节点后会更新多个节点</li><li>不涉及位置变动，只涉及修改数据的场景合适</li></ul><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><p><a href="https://fe.ecool.fun/topic-answer/f10c4b00-cceb-4323-97dc-55b315b05024?orderBy=updateTime&amp;order=desc" target="_blank" rel="noreferrer">我们应该在什么场景下使用 useMemo 和 useCallback </a></p>`,69),t=[n];function h(p,k,r,o,d,c){return i(),a("div",null,t)}const g=s(l,[["render",h]]);export{u as __pageData,g as default};
